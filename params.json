{
  "name": "ssm",
  "tagline": "手把手教你整合最优雅SSM框架：SpringMVC + Spring + MyBatis",
  "body": "# SSM\r\n手把手教你整合最优雅SSM框架：SpringMVC + Spring + MyBatis\r\n\r\n博客地址：[http://blog.csdn.net/qq598535550/article/details/51703190](http://blog.csdn.net/qq598535550/article/details/51703190)\r\n\r\n---------\r\n\r\n> 我们看招聘信息的时候，经常会看到这一点，需要具备SSH框架的技能；而且在大部分教学课堂中，也会把SSH作为最核心的教学内容。\r\n> 但是，我们在实际应用中发现，SpringMVC可以完全替代Struts，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。\r\n> 另外，MyBatis也可以替换Hibernate，正因为MyBatis的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。\r\n> 好了，如果你也认同我的看法，那么下面我们一起来做整合吧！\r\n\r\n在写代码之前我们先了解一下这三个框架分别是干什么的？\r\n相信大以前也看过不少这些概念，我这就用大白话来讲，如果之前有了解过可以跳过这一大段，直接看代码！\r\n\r\n 1. SpringMVC：它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！\r\n \r\n 2. Spring：太强大了，以至于我无法用一个词或一句话来概括它。但与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。\r\n\r\n 3. MyBatis：如果你问我它跟鼎鼎大名的Hibernate有什么区别？我只想说，他更符合我的需求。第一，它能自由控制sql，这会让有数据库经验的人（当然不是说我啦~捂脸~）编写的代码能搞提升数据库访问的效率。第二，它可以使用xml的方式来组织管理我们的sql，因为一般程序出错很多情况下是sql出错，别人接手代码后能快速找到出错地方，甚至可以优化原来写的sql。\r\n\r\n--------------\r\n\r\n## SSM框架整合配置\r\n\r\n好了，前面bb那么多，下面我们真正开始敲代码了~\r\n\r\n首先我们打开IED，我这里用的是eclipse（你们应该也是用的这个，对吗？），创建一个动态web项目，建立好相应的**目录结构**（重点！）\r\n\r\n![项目结构图](http://img.blog.csdn.net/20160618002041099)\r\n\r\n（打了马赛克是因为这里还用不到，你们不要那么污好不好？）\r\n\r\n我说一下每个目录都有什么用吧（第一次画表格，我发现markdown的表格语法很不友好呀~）\r\n这个目录结构同时也遵循maven的目录规范~\r\n| 文件名 | 作用 |\r\n| --- | --- |\r\n| src | 根目录，没什么好说的，下面有main和test。 |\r\n| - main | 主要目录，可以放java代码和一些资源文件。 |\r\n| - - java | 存放我们的java代码，这个文件夹要使用Build Path -> Use as Source Folder，这样看包结构会方便很多，新建的包就相当于在这里新建文件夹咯。 |\r\n| - - resources | 存放资源文件，譬如各种的spring，mybatis，log配置文件。 |\r\n| - - - mapper | 存放dao中每个方法对应的sql，在这里配置，无需写daoImpl。\r\n| - - - spring | 这里当然是存放spring相关的配置文件，有dao service web三层。 |\r\n| - - - sql | 其实这个可以没有，但是为了项目完整性还是加上吧。 |\r\n| - - - webapp | 这个貌似是最熟悉的目录了，用来存放我们前端的静态资源，如jsp js css。 |\r\n| - - - - resources | 这里的资源是指项目的静态资源，如js css images等。 |\r\n| - - - - WEB-INF | 很重要的一个目录，外部浏览器无法访问，只有羡慕内部才能访问，可以把jsp放在这里，另外就是web.xml了。你可能有疑问了，为什么上面java中的resources里面的配置文件不妨在这里，那么是不是会被外部窃取到？你想太多了，部署时候基本上只有webapp里的会直接输出到根目录，其他都会放入WEB-INF里面，项目内部依然可以使用classpath:XXX来访问，好像IDE里可以设置部署输出目录，这里扯远了~ |\r\n| - test | 这里是测试分支。 |\r\n| - - java | 测试java代码，应遵循包名相同的原则，这个文件夹同样要使用Build Path -> Use as Source Folder，这样看包结构会方便很多。 |\r\n| - - resources | 没什么好说的，好像也很少用到，但这个是maven的规范。 |\r\n\r\n\r\n---------------\r\n\r\n我先新建好几个必要的**包**，并为大家讲解一下每个包的作用，顺便理清一下后台的思路~\r\n\r\n![包结构图](http://img.blog.csdn.net/20160618004306660)\r\n\r\n| 包名 | 名称 | 作用 |\r\n| --- | --- | --- |\r\n| dao | 数据访问层（接口） | 与数据打交道，可以是数据库操作，也可以是文件读写操作，甚至是redis缓存操作，总之与数据操作有关的都放在这里，也有人叫做dal或者数据持久层都差不多意思。为什么没有daoImpl，因为我们用的是mybatis，所以可以直接在配置文件中实现接口的每个方法。 |\r\n| entity | 实体类 | 一般与数据库的表相对应，封装dao层取出来的数据为一个对象，也就是我们常说的pojo，一般只在dao层与service层之间传输。 |\r\n| dto | 数据传输层 | 刚学框架的人可能不明白这个有什么用，其实就是用于service层与web层之间传输，为什么不直接用entity（pojo）？其实在实际开发中发现，很多时间一个entity并不能满足我们的业务需求，可能呈现给用户的信息十分之多，这时候就有了dto，也相当于vo，记住一定不要把这个混杂在entity里面，答应我好吗？ |\r\n| service | 业务逻辑（接口） | 写我们的业务逻辑，也有人叫bll，在设计业务接口时候应该站在“使用者”的角度。额，不要问我为什么这里没显示！IDE调皮我也拿它没办法~ |\r\n| serviceImpl | 业务逻辑（实现） | 实现我们业务接口，一般事务控制是写在这里，没什么好说的。 |\r\n| web | 控制器 | springmvc就是在这里发挥作用的，一般人叫做controller控制器，相当于struts中的action。 |\r\n\r\n\r\n-----------\r\n\r\n还有最后一步基础工作，导入我们相应的jar包，我使用的是maven来管理我们的jar，所以只需要在`poom.xml`中加入相应的依赖就好了，如果不使用maven的可以自己去官网下载相应的jar，放到项目WEB-INF/lib目录下。关于maven的学习大家可以看[慕课网的视频教程](http://www.imooc.com/learn/443)，这里就不展开了。我把项目用到的jar都写在下面，版本都不是最新的，大家有经验的话可以自己调整版本号。另外，所有jar都会与项目一起打包放到我的[github](https://github.com/liyifeng1994/ssm)上，喜欢的给个star吧~\r\n\r\n**poom.xml**\r\n``` xml\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n\t<modelVersion>4.0.0</modelVersion>\r\n\t<groupId>com.soecode.ssm</groupId>\r\n\t<artifactId>ssm</artifactId>\r\n\t<packaging>war</packaging>\r\n\t<version>0.0.1-SNAPSHOT</version>\r\n\t<name>ssm Maven Webapp</name>\r\n\t<url>http://github.com/liyifeng1994/ssm</url>\r\n\t<dependencies>\r\n\t\t<!-- 单元测试 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>junit</groupId>\r\n\t\t\t<artifactId>junit</artifactId>\r\n\t\t\t<version>4.11</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- 1.日志 -->\r\n\t\t<!-- 实现slf4j接口并整合 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>ch.qos.logback</groupId>\r\n\t\t\t<artifactId>logback-classic</artifactId>\r\n\t\t\t<version>1.1.1</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- 2.数据库 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>mysql</groupId>\r\n\t\t\t<artifactId>mysql-connector-java</artifactId>\r\n\t\t\t<version>5.1.37</version>\r\n\t\t\t<scope>runtime</scope>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>c3p0</groupId>\r\n\t\t\t<artifactId>c3p0</artifactId>\r\n\t\t\t<version>0.9.1.2</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- DAO: MyBatis -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.mybatis</groupId>\r\n\t\t\t<artifactId>mybatis</artifactId>\r\n\t\t\t<version>3.3.0</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.mybatis</groupId>\r\n\t\t\t<artifactId>mybatis-spring</artifactId>\r\n\t\t\t<version>1.2.3</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- 3.Servlet web -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>taglibs</groupId>\r\n\t\t\t<artifactId>standard</artifactId>\r\n\t\t\t<version>1.1.2</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>jstl</groupId>\r\n\t\t\t<artifactId>jstl</artifactId>\r\n\t\t\t<version>1.2</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\r\n\t\t\t<artifactId>jackson-databind</artifactId>\r\n\t\t\t<version>2.5.4</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>javax.servlet</groupId>\r\n\t\t\t<artifactId>javax.servlet-api</artifactId>\r\n\t\t\t<version>3.1.0</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- 4.Spring -->\r\n\t\t<!-- 1)Spring核心 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-core</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-beans</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-context</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<!-- 2)Spring DAO层 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-jdbc</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-tx</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<!-- 3)Spring web -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-web</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-webmvc</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\t\t<!-- 4)Spring test -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework</groupId>\r\n\t\t\t<artifactId>spring-test</artifactId>\r\n\t\t\t<version>4.1.7.RELEASE</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- redis客户端:Jedis -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>redis.clients</groupId>\r\n\t\t\t<artifactId>jedis</artifactId>\r\n\t\t\t<version>2.7.3</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>com.dyuproject.protostuff</groupId>\r\n\t\t\t<artifactId>protostuff-core</artifactId>\r\n\t\t\t<version>1.0.8</version>\r\n\t\t</dependency>\r\n\t\t<dependency>\r\n\t\t\t<groupId>com.dyuproject.protostuff</groupId>\r\n\t\t\t<artifactId>protostuff-runtime</artifactId>\r\n\t\t\t<version>1.0.8</version>\r\n\t\t</dependency>\r\n\r\n\t\t<!-- Map工具类 -->\r\n\t\t<dependency>\r\n\t\t\t<groupId>commons-collections</groupId>\r\n\t\t\t<artifactId>commons-collections</artifactId>\r\n\t\t\t<version>3.2</version>\r\n\t\t</dependency>\r\n\t</dependencies>\r\n\t<build>\r\n\t\t<finalName>ssm</finalName>\r\n\t</build>\r\n</project>\r\n\r\n```\r\n\r\n-----------\r\n\r\n下面真的要开始进行编码工作了，坚持到这里辛苦大家了~\r\n\r\n第一步：我们先在`spring`文件夹里新建`spring-dao.xml`文件，因为spring的配置太多，我们这里分三层，分别是dao service web。\r\n\r\n 1. 读入数据库连接相关参数（可选）\r\n 2. 配置数据连接池\r\n  1. 配置连接属性，可以不读配置项文件直接在这里写死\r\n  2. 配置c3p0，只配了几个常用的\r\n 3. 配置SqlSessionFactory对象（mybatis）\r\n 4. 扫描dao层接口，动态实现dao接口，也就是说不需要daoImpl，sql和参数都写在xml文件上\r\n\r\n**spring-dao.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\r\n\thttp://www.springframework.org/schema/context\r\n\thttp://www.springframework.org/schema/context/spring-context.xsd\">\r\n\t<!-- 配置整合mybatis过程 -->\r\n\t<!-- 1.配置数据库相关参数properties的属性：${url} -->\r\n\t<context:property-placeholder location=\"classpath:jdbc.properties\" />\r\n\r\n\t<!-- 2.数据库连接池 -->\r\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\r\n\t\t<!-- 配置连接池属性 -->\r\n\t\t<property name=\"driverClass\" value=\"${jdbc.driver}\" />\r\n\t\t<property name=\"jdbcUrl\" value=\"${jdbc.url}\" />\r\n\t\t<property name=\"user\" value=\"${jdbc.username}\" />\r\n\t\t<property name=\"password\" value=\"${jdbc.password}\" />\r\n\r\n\t\t<!-- c3p0连接池的私有属性 -->\r\n\t\t<property name=\"maxPoolSize\" value=\"30\" />\r\n\t\t<property name=\"minPoolSize\" value=\"10\" />\r\n\t\t<!-- 关闭连接后不自动commit -->\r\n\t\t<property name=\"autoCommitOnClose\" value=\"false\" />\r\n\t\t<!-- 获取连接超时时间 -->\r\n\t\t<property name=\"checkoutTimeout\" value=\"10000\" />\r\n\t\t<!-- 当获取连接失败重试次数 -->\r\n\t\t<property name=\"acquireRetryAttempts\" value=\"2\" />\r\n\t</bean>\r\n\r\n\t<!-- 3.配置SqlSessionFactory对象 -->\r\n\t<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n\t\t<!-- 注入数据库连接池 -->\r\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\r\n\t\t<!-- 配置MyBaties全局配置文件:mybatis-config.xml -->\r\n\t\t<property name=\"configLocation\" value=\"classpath:mybatis-config.xml\" />\r\n\t\t<!-- 扫描entity包 使用别名 -->\r\n\t\t<property name=\"typeAliasesPackage\" value=\"com.soecode.lyf.entity\" />\r\n\t\t<!-- 扫描sql配置文件:mapper需要的xml文件 -->\r\n\t\t<property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\" />\r\n\t</bean>\r\n\r\n\t<!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 -->\r\n\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n\t\t<!-- 注入sqlSessionFactory -->\r\n\t\t<property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\r\n\t\t<!-- 给出需要扫描Dao接口包 -->\r\n\t\t<property name=\"basePackage\" value=\"com.soecode.lyf.dao\" />\r\n\t</bean>\r\n</beans>\r\n```\r\n因为数据库配置相关参数是读取配置文件，所以在`resources`文件夹里新建一个`jdbc.properties`文件，存放我们4个最常见的数据库连接属性，这是我本地的，大家记得修改呀~还有喜欢传到github上“大头虾们”记得删掉密码，不然别人就很容易得到你服务器的数据库配置信息，然后干一些羞羞的事情，你懂的！！\r\n\r\n**jdbc.properties**\r\n``` properties\r\njdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://localhost:3307/ssm?useUnicode=true&characterEncoding=utf8\r\njdbc.username=root\r\njdbc.password=\r\n```\r\n**友情提示**：配置文件中的jdbc.username，如果写成username，可能会与系统环境中的username变量冲突，所以到时候真正连接数据库的时候，用户名就被替换成系统中的用户名（有得可能是administrator），那肯定是连接不成功的，这里有个小坑，我被坑了一晚上！！\r\n\r\n因为这里用到了mybatis，所以需要配置mybatis核心文件，在`recources`文件夹里新建`mybatis-config.xml`文件。\r\n\r\n 1. 使用自增主键\r\n 2. 使用列别名\r\n 3. 开启驼峰命名转换 create_time -> createTime\r\n\r\n**mybatis-config.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n\t<!-- 配置全局属性 -->\r\n\t<settings>\r\n\t\t<!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 -->\r\n\t\t<setting name=\"useGeneratedKeys\" value=\"true\" />\r\n\r\n\t\t<!-- 使用列别名替换列名 默认:true -->\r\n\t\t<setting name=\"useColumnLabel\" value=\"true\" />\r\n\r\n\t\t<!-- 开启驼峰命名转换:Table{create_time} -> Entity{createTime} -->\r\n\t\t<setting name=\"mapUnderscoreToCamelCase\" value=\"true\" />\r\n\t</settings>\r\n</configuration>\r\n```\r\n\r\n第二步：刚弄好dao层，接下来到service层了。在`spring`文件夹里新建`spring-service.xml`文件。\r\n\r\n 1. 扫描service包所有注解 @Service\r\n 2. 配置事务管理器，把事务管理交由spring来完成\r\n 3. 配置基于注解的声明式事务，可以直接在方法上@Transaction\r\n\r\n**spring-service.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \r\n\txmlns:context=\"http://www.springframework.org/schema/context\"\r\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\r\n\thttp://www.springframework.org/schema/context\r\n\thttp://www.springframework.org/schema/context/spring-context.xsd\r\n\thttp://www.springframework.org/schema/tx\r\n\thttp://www.springframework.org/schema/tx/spring-tx.xsd\">\r\n\t<!-- 扫描service包下所有使用注解的类型 -->\r\n\t<context:component-scan base-package=\"com.soecode.lyf.service\" />\r\n\r\n\t<!-- 配置事务管理器 -->\r\n\t<bean id=\"transactionManager\"\r\n\t\tclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n\t\t<!-- 注入数据库连接池 -->\r\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\r\n\t</bean>\r\n\r\n\t<!-- 配置基于注解的声明式事务 -->\r\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\r\n</beans>\r\n```\r\n\r\n-------------\r\n\r\n第三步：配置web层，在`spring`文件夹里新建`spring-web.xml`文件。\r\n\r\n 1. 开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等\r\n 2. 对静态资源处理，如js，css，jpg等\r\n 3. 配置jsp 显示ViewResolver，例如在controller中某个方法返回一个string类型的\"login\"，实际上会返回\"/WEB-INF/login.jsp\"\r\n 4. 扫描web层 @Controller\r\n\r\n**spring-web.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txmlns:context=\"http://www.springframework.org/schema/context\"\r\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\r\n\thttp://www.springframework.org/schema/context\r\n\thttp://www.springframework.org/schema/context/spring-context.xsd\r\n\thttp://www.springframework.org/schema/mvc\r\n\thttp://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\">\r\n\t<!-- 配置SpringMVC -->\r\n\t<!-- 1.开启SpringMVC注解模式 -->\r\n\t<!-- 简化配置： \r\n\t\t(1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter \r\n\t\t(2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 \r\n\t-->\r\n\t<mvc:annotation-driven />\r\n\t\r\n\t<!-- 2.静态资源默认servlet配置\r\n\t\t(1)加入对静态资源的处理：js,gif,png\r\n\t\t(2)允许使用\"/\"做整体映射\r\n\t -->\r\n\t <mvc:default-servlet-handler/>\r\n\t \r\n\t <!-- 3.配置jsp 显示ViewResolver -->\r\n\t <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n\t \t<property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" />\r\n\t \t<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\r\n\t \t<property name=\"suffix\" value=\".jsp\" />\r\n\t </bean>\r\n\t \r\n\t <!-- 4.扫描web相关的bean -->\r\n\t <context:component-scan base-package=\"com.soecode.lyf.web\" />\r\n</beans>\r\n```\r\n\r\n------------\r\n\r\n第四步：最后就是修改`web.xml`文件了，它在`webapp`的`WEB-INF`下。\r\n\r\n**web.xml**\r\n``` xml\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\r\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n\tversion=\"3.1\" metadata-complete=\"true\">\r\n\t<!-- 如果是用mvn命令生成的xml，需要修改servlet版本为3.1 -->\r\n\t<!-- 配置DispatcherServlet -->\r\n\t<servlet>\r\n\t\t<servlet-name>seckill-dispatcher</servlet-name>\r\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n\t\t<!-- 配置springMVC需要加载的配置文件\r\n\t\t\tspring-dao.xml,spring-service.xml,spring-web.xml\r\n\t\t\tMybatis - > spring -> springmvc\r\n\t\t -->\r\n\t\t<init-param>\r\n\t\t\t<param-name>contextConfigLocation</param-name>\r\n\t\t\t<param-value>classpath:spring/spring-*.xml</param-value>\r\n\t\t</init-param>\r\n\t</servlet>\r\n\t<servlet-mapping>\r\n\t\t<servlet-name>seckill-dispatcher</servlet-name>\r\n\t\t<!-- 默认匹配所有的请求 -->\r\n\t\t<url-pattern>/</url-pattern>\r\n\t</servlet-mapping>\r\n</web-app>\r\n\r\n```\r\n\r\n-----------\r\n\r\n我们在项目中经常会使用到日志，所以这里还有配置日志xml，在`resources`文件夹里新建`logback.xml`文件，所给出的日志输出格式也是最基本的控制台s呼出，大家有兴趣查看[logback官方文档](http://logback.qos.ch/manual/)。\r\n\r\n**logback.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration debug=\"true\">\r\n\t<appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n\t\t<!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder -->\r\n\t\t<encoder>\r\n\t\t\t<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n\t\t</encoder>\r\n\t</appender>\r\n\r\n\t<root level=\"debug\">\r\n\t\t<appender-ref ref=\"STDOUT\" />\r\n\t</root>\r\n</configuration>\r\n```\r\n\r\n-----------\r\n\r\n到目前为止，我们一共写了7个配置文件，我们一起来看下最终的**配置文件结构图**。\r\n\r\n![配置文件结构图](http://img.blog.csdn.net/20160618142208354)\r\n\r\n----------\r\n\r\n## SSM框架应用实例（图书管理系统）\r\n\r\n> 一开始想就这样结束教程，但是发现其实很多人都还不会把这个SSM框架用起来，特别是mybatis部分。那我现在就以最常见的“图书管理系统”中【查询图书】和【预约图书】业务来做一个demo吧！\r\n\r\n首先新建数据库名为`ssm`，再创建两张表：图书表`book`和预约图书表`appointment`，并且为`book`表初始化一些数据，sql如下。\r\n\r\n**schema.sql**\r\n``` sql\r\n-- 创建图书表\r\nCREATE TABLE `book` (\r\n  `book_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '图书ID',\r\n  `name` varchar(100) NOT NULL COMMENT '图书名称',\r\n  `number` int(11) NOT NULL COMMENT '馆藏数量',\r\n  PRIMARY KEY (`book_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT='图书表'\r\n\r\n-- 初始化图书数据\r\nINSERT INTO `book` (`book_id`, `name`, `number`)\r\nVALUES\r\n\t(1000, 'Java程序设计', 10),\r\n\t(1001, '数据结构', 10),\r\n\t(1002, '设计模式', 10),\r\n\t(1003, '编译原理', 10)\r\n\r\n-- 创建预约图书表\r\nCREATE TABLE `appointment` (\r\n  `book_id` bigint(20) NOT NULL COMMENT '图书ID',\r\n  `student_id` bigint(20) NOT NULL COMMENT '学号',\r\n  `appoint_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '预约时间' ,\r\n  PRIMARY KEY (`book_id`, `student_id`),\r\n  INDEX `idx_appoint_time` (`appoint_time`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='预约图书表'\r\n```\r\n\r\n------------\r\n\r\n在`entity`包中添加两个对应的实体，图书实体`Book.java`和预约图书实体`Appointment.java`。\r\n\r\n**Book.java**\r\n```java\r\npackage com.soecode.lyf.entity;\r\n\r\npublic class Book {\r\n\r\n\tprivate long bookId;// 图书ID\r\n\r\n\tprivate String name;// 图书名称\r\n\r\n\tprivate int number;// 馆藏数量\r\n\r\n\t// 省略构造方法，getter和setter方法，toString方法\r\n\r\n}\r\n```\r\n\r\n**Appointment.java**\r\n``` java\r\npackage com.soecode.lyf.entity;\r\n\r\nimport java.util.Date;\r\n\r\n/**\r\n * 预约图书实体\r\n */\r\npublic class Appointment {\r\n\r\n\tprivate long bookId;// 图书ID\r\n\r\n\tprivate long studentId;// 学号\r\n\r\n\tprivate Date appointTime;// 预约时间\r\n\r\n\t// 多对一的复合属性\r\n\tprivate Book book;// 图书实体\r\n\t\r\n\t// 省略构造方法，getter和setter方法，toString方法\r\n\r\n}\r\n```\r\n\r\n------------\r\n\r\n在`dao`包新建接口`BookDao.java`和`Appointment.java`\r\n\r\n**BookDao.java**\r\n``` java\r\npackage com.soecode.lyf.dao;\r\n\r\nimport java.util.List;\r\n\r\nimport com.soecode.lyf.entity.Book;\r\n\r\npublic interface BookDao {\r\n\r\n\t/**\r\n\t * 通过ID查询单本图书\r\n\t * \r\n\t * @param id\r\n\t * @return\r\n\t */\r\n\tBook queryById(long id);\r\n\r\n\t/**\r\n\t * 查询所有图书\r\n\t * \r\n\t * @param offset 查询起始位置\r\n\t * @param limit 查询条数\r\n\t * @return\r\n\t */\r\n\tList<Book> queryAll(@Param(\"offset\") int offset, @Param(\"limit\") int limit);\r\n\r\n\t/**\r\n\t * 减少馆藏数量\r\n\t * \r\n\t * @param bookId\r\n\t * @return 如果影响行数等于>1，表示更新的记录行数\r\n\t */\r\n\tint reduceNumber(long bookId);\r\n}\r\n\r\n```\r\n\r\n**AppointmentDao.java**\r\n```java\r\npackage com.soecode.lyf.dao;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\nimport com.soecode.lyf.entity.Appointment;\r\n\r\npublic interface AppointmentDao {\r\n\r\n\t/**\r\n\t * 插入预约图书记录\r\n\t * \r\n\t * @param bookId\r\n\t * @param studentId\r\n\t * @return 插入的行数\r\n\t */\r\n\tint insertAppointment(@Param(\"bookId\") long bookId, @Param(\"studentId\") long studentId);\r\n\r\n\t/**\r\n\t * 通过主键查询预约图书记录，并且携带图书实体\r\n\t * \r\n\t * @param bookId\r\n\t * @param studentId\r\n\t * @return\r\n\t */\r\n\tAppointment queryByKeyWithBook(@Param(\"bookId\") long bookId, @Param(\"studentId\") long studentId);\r\n\r\n}\r\n```\r\n**提示**：这里为什么要给方法的参数添加`@Param`注解呢？是因为该方法有两个或以上的参数，一定要加，不然mybatis识别不了。上面的`BookDao`接口的`queryById`方法和`reduceNumber`方法只有一个参数`book_id`，所以可以不用加 `@Param`注解，当然加了也无所谓~\r\n\r\n---------------\r\n\r\n注意，这里不需要实现dao接口不用编写daoImpl， mybatis会给我们动态实现，但是我们需要编写相应的mapper。\r\n在`mapper`目录里新建两个文件`BookDao.xml`和`AppointmentDao.xml`，分别对应上面两个dao接口，代码如下。\r\n\r\n**BookDao.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper\r\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.soecode.lyf.dao.BookDao\">\r\n\t<!-- 目的：为dao接口方法提供sql语句配置 -->\r\n\t<select id=\"queryById\" resultType=\"Book\" parameterType=\"long\">\r\n\t\t<!-- 具体的sql -->\r\n\t\tSELECT\r\n\t\t\tbook_id,\r\n\t\t\tname,\r\n\t\t\tnumber\r\n\t\tFROM\r\n\t\t\tbook\r\n\t\tWHERE\r\n\t\t\tbook_id = #{bookId}\r\n\t</select>\r\n\t\r\n\t<select id=\"queryAll\" resultType=\"Book\">\r\n\t\tSELECT\r\n\t\t\tbook_id,\r\n\t\t\tname,\r\n\t\t\tnumber\r\n\t\tFROM\r\n\t\t\tbook\r\n\t\tORDER BY\r\n\t\t\tbook_id\r\n\t\tLIMIT #{offset}, #{limit}\r\n\t</select>\r\n\t\r\n\t<update id=\"reduceNumber\">\r\n\t\tUPDATE book\r\n\t\tSET number = number - 1\r\n\t\tWHERE\r\n\t\t\tbook_id = #{bookId}\r\n\t\tAND number > 0\r\n\t</update>\r\n</mapper>\r\n```\r\n\r\n**AppointmentDao.xml**\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper\r\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.soecode.lyf.dao.AppointmentDao\">\r\n\t<insert id=\"insertAppointment\">\r\n\t\t<!-- ignore 主键冲突，报错 -->\r\n\t\tINSERT ignore INTO appointment (book_id, student_id)\r\n\t\tVALUES (#{bookId}, #{studentId})\r\n\t</insert>\r\n\t\r\n\t<select id=\"queryByKeyWithBook\" resultType=\"Appointment\">\r\n\t\t<!-- 如何告诉MyBatis把结果映射到Appointment同时映射book属性 -->\r\n\t\t<!-- 可以自由控制SQL -->\r\n\t\tSELECT\r\n\t\t\ta.book_id,\r\n\t\t\ta.student_id,\r\n\t\t\ta.appoint_time,\r\n\t\t\tb.book_id \"book.book_id\",\r\n\t\t\tb.`name` \"book.name\",\r\n\t\t\tb.number \"book.number\"\r\n\t\tFROM\r\n\t\t\tappointment a\r\n\t\tINNER JOIN book b ON a.book_id = b.book_id\r\n\t\tWHERE\r\n\t\t\ta.book_id = #{bookId}\r\n\t\tAND a.student_id = #{studentId}\r\n\t</select>\r\n</mapper>\r\n```\r\n\r\n**mapper总结**：`namespace`是该xml对应的接口全名，`select`和`update`中的`id`对应方法名，`resultType`是返回值类型，`parameterType`是参数类型（这个其实可选），最后`#{...}`中填写的是方法的参数，看懂了是不是很简单！！我也这么觉得~ 还有一个小技巧要交给大家，就是在返回`Appointment`对象包含了一个属性名为`book`的Book对象，那么可以使用`\"book.属性名\"`的方式来取值，看上面`queryByKeyWithBook`方法的sql。\r\n\r\n------------\r\n\r\n`dao`层写完了，接下来`test`对应的`package`写我们测试方法吧。\r\n因为我们之后会写很多测试方法，在测试前需要让程序读入spring-dao和mybatis等配置文件，所以我这里就抽离出来一个`BaseTest`类，只要是测试方法就继承它，这样那些繁琐的重复的代码就不用写那么多了~\r\n\r\n**BaseTest.java**\r\n``` java\r\npackage com.soecode.lyf;\r\n\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\r\n\r\n/**\r\n * 配置spring和junit整合，junit启动时加载springIOC容器 spring-test,junit\r\n */\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n// 告诉junit spring配置文件\r\n@ContextConfiguration({ \"classpath:spring/spring-dao.xml\", \"classpath:spring/spring-service.xml\" })\r\npublic class BaseTest {\r\n\r\n}\r\n\r\n```\r\n因为`spring-service`在`service`层的测试中会时候到，这里也一起引入算了！\r\n\r\n新建`BookDaoTest.java`和`AppointmentDaoTest.java`两个dao测试文件。\r\n\r\n**BookDaoTest.java**\r\n``` java\r\npackage com.soecode.lyf.dao;\r\n\r\nimport java.util.List;\r\n\r\nimport org.junit.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport com.soecode.lyf.BaseTest;\r\nimport com.soecode.lyf.entity.Book;\r\n\r\npublic class BookDaoTest extends BaseTest {\r\n\r\n\t@Autowired\r\n\tprivate BookDao bookDao;\r\n\r\n\t@Test\r\n\tpublic void testQueryById() throws Exception {\r\n\t\tlong bookId = 1000;\r\n\t\tBook book = bookDao.queryById(bookId);\r\n\t\tSystem.out.println(book);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testQueryAll() throws Exception {\r\n\t\tList<Book> books = bookDao.queryAll(0, 4);\r\n\t\tfor (Book book : books) {\r\n\t\t\tSystem.out.println(book);\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testReduceNumber() throws Exception {\r\n\t\tlong bookId = 1000;\r\n\t\tint update = bookDao.reduceNumber(bookId);\r\n\t\tSystem.out.println(\"update=\" + update);\r\n\t}\r\n\r\n}\r\n```\r\n#### BookDaoTest测试结果\r\n\r\n***testQueryById***\r\n![testQueryById](http://img.bbs.csdn.net/upload/201606/18/1466255160_717902.png)\r\n\r\n***testQueryAll***\r\n![testQueryAll](http://img.bbs.csdn.net/upload/201606/18/1466255452_743822.png)\r\n\r\n***testReduceNumber***\r\n![testReduceNumber](http://img.bbs.csdn.net/upload/201606/18/1466255505_256048.png)\r\n\r\n\r\n**AppointmentDaoTest.java**\r\n``` java\r\npackage com.soecode.lyf.dao;\r\n\r\nimport org.junit.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport com.soecode.lyf.BaseTest;\r\nimport com.soecode.lyf.entity.Appointment;\r\n\r\npublic class AppointmentDaoTest extends BaseTest {\r\n\r\n\t@Autowired\r\n\tprivate AppointmentDao appointmentDao;\r\n\r\n\t@Test\r\n\tpublic void testInsertAppointment() throws Exception {\r\n\t\tlong bookId = 1000;\r\n\t\tlong studentId = 12345678910L;\r\n\t\tint insert = appointmentDao.insertAppointment(bookId, studentId);\r\n\t\tSystem.out.println(\"insert=\" + insert);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testQueryByKeyWithBook() throws Exception {\r\n\t\tlong bookId = 1000;\r\n\t\tlong studentId = 12345678910L;\r\n\t\tAppointment appointment = appointmentDao.queryByKeyWithBook(bookId, studentId);\r\n\t\tSystem.out.println(appointment);\r\n\t\tSystem.out.println(appointment.getBook());\r\n\t}\r\n\r\n}\r\n```\r\n####AppointmentDaoTest测试结果\r\n\r\n***testInsertAppointment***\r\n![testInsertAppointment](http://img.bbs.csdn.net/upload/201606/18/1466255520_227298.png)\r\n\r\n***testQueryByKeyWithBook***\r\n![testQueryByKeyWithBook](http://img.bbs.csdn.net/upload/201606/18/1466255537_831651.png)\r\n\r\n-------------\r\n\r\n嗯，到这里一切到很顺利~那么我们继续service层的编码吧~可能下面开始信息里比较大，大家要做好心理准备~\r\n\r\n首先，在写我们的业务之前，我们先定义几个预约图书操作返回码的数据字典，我们这类使用枚举类，没听过的小伙伴要好好恶补一下了（我也是最近才学到的= =）\r\n\r\n**预约业务操作返回码说明**\r\n\r\n| 返回码 | 说明 |\r\n| --- | --- |\r\n| 1 | 预约成功 |\r\n| 0 | 库存不足 |\r\n| -1 | 重复预约 |\r\n| -2 | 系统异常 |\r\n\r\n新建一个包叫`enums`，在里面新建一个枚举类`AppointStateEnum.java`，用来定义预约业务的数据字典，没听懂没关系，我们直接看代码吧~是不是感觉有模有样了！\r\n\r\n**AppointStateEnum.java**\r\n```java\r\npackage com.soecode.lyf.enums;\r\n\r\n/**\r\n * 使用枚举表述常量数据字典\r\n */\r\npublic enum AppointStateEnum {\r\n\r\n\tSUCCESS(1, \"预约成功\"), NO_NUMBER(0, \"库存不足\"), REPEAT_APPOINT(-1, \"重复预约\"), INNER_ERROR(-2, \"系统异常\");\r\n\r\n\tprivate int state;\r\n\r\n\tprivate String stateInfo;\r\n\r\n\tprivate AppointStateEnum(int state, String stateInfo) {\r\n\t\tthis.state = state;\r\n\t\tthis.stateInfo = stateInfo;\r\n\t}\r\n\r\n\tpublic int getState() {\r\n\t\treturn state;\r\n\t}\r\n\r\n\tpublic String getStateInfo() {\r\n\t\treturn stateInfo;\r\n\t}\r\n\r\n\tpublic static AppointStateEnum stateOf(int index) {\r\n\t\tfor (AppointStateEnum state : values()) {\r\n\t\t\tif (state.getState() == index) {\r\n\t\t\t\treturn state;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n```\r\n-------------\r\n\r\n接下来，在`dto`包下新建`AppointExecution.java`用来存储我们执行预约操作的返回结果。\r\n\r\n**AppointExecution.java**\r\n```java\r\npackage com.soecode.lyf.dto;\r\n\r\nimport com.soecode.lyf.entity.Appointment;\r\nimport com.soecode.lyf.enums.AppointStateEnum;\r\n\r\n/**\r\n * 封装预约执行后结果\r\n */\r\npublic class AppointExecution {\r\n\r\n\t// 图书ID\r\n\tprivate long bookId;\r\n\r\n\t// 秒杀预约结果状态\r\n\tprivate int state;\r\n\r\n\t// 状态标识\r\n\tprivate String stateInfo;\r\n\r\n\t// 预约成功对象\r\n\tprivate Appointment appointment;\r\n\r\n\tpublic AppointExecution() {\r\n\t}\r\n\r\n\t// 预约失败的构造器\r\n\tpublic AppointExecution(long bookId, AppointStateEnum stateEnum) {\r\n\t\tthis.bookId = bookId;\r\n\t\tthis.state = stateEnum.getState();\r\n\t\tthis.stateInfo = stateEnum.getStateInfo();\r\n\t}\r\n\r\n\t// 预约成功的构造器\r\n\tpublic AppointExecution(long bookId, AppointStateEnum stateEnum, Appointment appointment) {\r\n\t\tthis.bookId = bookId;\r\n\t\tthis.state = stateEnum.getState();\r\n\t\tthis.stateInfo = stateEnum.getStateInfo();\r\n\t\tthis.appointment = appointment;\r\n\t}\r\n\t\r\n\t// 省略getter和setter方法，toString方法\r\n\r\n}\r\n\r\n```\r\n\r\n-------------\r\n\r\n咱们终于可以编写业务代码了，在`service`包下新建`BookService.java`图书业务接口。\r\n\r\n**BookService.java**\r\n``` java\r\npackage com.soecode.lyf.service;\r\n\r\nimport java.util.List;\r\n\r\nimport com.soecode.lyf.dto.AppointExecution;\r\nimport com.soecode.lyf.entity.Book;\r\n\r\n/**\r\n * 业务接口：站在\"使用者\"角度设计接口 三个方面：方法定义粒度，参数，返回类型（return 类型/异常）\r\n */\r\npublic interface BookService {\r\n\r\n\t/**\r\n\t * 查询一本图书\r\n\t * \r\n\t * @param bookId\r\n\t * @return\r\n\t */\r\n\tBook getById(long bookId);\r\n\r\n\t/**\r\n\t * 查询所有图书\r\n\t * \r\n\t * @return\r\n\t */\r\n\tList<Book> getList();\r\n\r\n\t/**\r\n\t * 预约图书\r\n\t * \r\n\t * @param bookId\r\n\t * @param studentId\r\n\t * @return\r\n\t */\r\n\tAppointExecution appoint(long bookId, long studentId);\r\n\r\n}\r\n```\r\n\r\n在`service.impl`包下新建`BookServiceImpl.java`使用`BookService`接口，并实现里面的方法。\r\n\r\n**BookServiceImpl**\r\n``` java\r\npackage com.soecode.lyf.service.impl;\r\n\r\nimport java.util.List;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport com.soecode.lyf.dao.AppointmentDao;\r\nimport com.soecode.lyf.dao.BookDao;\r\nimport com.soecode.lyf.dto.AppointExecution;\r\nimport com.soecode.lyf.entity.Appointment;\r\nimport com.soecode.lyf.entity.Book;\r\nimport com.soecode.lyf.enums.AppointStateEnum;\r\nimport com.soecode.lyf.service.BookService;\r\n\r\n@Service\r\npublic class BookServiceImpl implements BookService {\r\n\r\n\tprivate Logger logger = LoggerFactory.getLogger(this.getClass());\r\n\r\n\t// 注入Service依赖\r\n\t@Autowired\r\n\tprivate BookDao bookDao;\r\n\r\n\t@Autowired\r\n\tprivate AppointmentDao appointmentDao;\r\n\r\n\r\n\t@Override\r\n\tpublic Book getById(long bookId) {\r\n\t\treturn bookDao.queryById(bookId);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic List<Book> getList() {\r\n\t\treturn bookDao.queryAll(0, 1000);\r\n\t}\r\n\r\n\t@Override\r\n\t@Transactional\r\n\t/**\r\n\t * 使用注解控制事务方法的优点： 1.开发团队达成一致约定，明确标注事务方法的编程风格\r\n\t * 2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作，RPC/HTTP请求或者剥离到事务方法外部\r\n\t * 3.不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制\r\n\t */\r\n\tpublic AppointExecution appoint(long bookId, long studentId) {\r\n\t\ttry {\r\n\t\t\t// 减库存\r\n\t\t\tint update = bookDao.reduceNumber(bookId);\r\n\t\t\tif (update <= 0) {// 库存不足\r\n\t\t\t\treturn new AppointExecution(bookId, AppointStateEnum.NO_NUMBER);\r\n\t\t\t} else {\r\n\t\t\t\t// 执行预约操作\r\n\t\t\t\tint insert = appointmentDao.insertAppointment(bookId, studentId);\r\n\t\t\t\tif (insert <= 0) {// 重复预约\r\n\t\t\t\t\treturn new AppointExecution(bookId, AppointStateEnum.REPEAT_APPOINT);\r\n\t\t\t\t} else {// 预约成功\r\n\t\t\t\t\tAppointment appointment = appointmentDao.queryByKeyWithBook(bookId, studentId);\r\n\t\t\t\t\treturn new AppointExecution(bookId, AppointStateEnum.SUCCESS, appointment);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\t// 所有编译期异常转换为运行期异常\r\n\t\t\treturn new AppointExecution(bookId, AppointStateEnum.INNER_ERROR);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n--------------\r\n\r\n下面我们来测试一下我们的业务代码吧~因为查询图书的业务不复杂，所以这里只演示我们最重要的预约图书业务！！\r\n\r\n**BookServiceImplTest.java**\r\n``` java\r\npackage com.soecode.lyf.service.impl;\r\n\r\nimport static org.junit.Assert.fail;\r\n\r\nimport org.junit.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport com.soecode.lyf.BaseTest;\r\nimport com.soecode.lyf.dto.AppointExecution;\r\nimport com.soecode.lyf.service.BookService;\r\n\r\npublic class BookServiceImplTest extends BaseTest {\r\n\r\n\t@Autowired\r\n\tprivate BookService bookService;\r\n\r\n\t@Test\r\n\tpublic void testAppoint() throws Exception {\r\n\t\tlong bookId = 1001;\r\n\t\tlong studentId = 12345678910L;\r\n\t\tAppointExecution execution = bookService.appoint(bookId, studentId);\r\n\t\tSystem.out.println(execution);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n#### BookServiceImplTest测试结果\r\n\r\n***testAppoint***\r\n![testAppoint](http://img.bbs.csdn.net/upload/201606/19/1466270053_292015.png)\r\n\r\n首次执行是“预约成功”，如果再次执行的话，应该会出现“重复预约”，哈哈，我们所有的后台代码都通过单元测试啦~~是不是很开心~\r\n\r\n-------------\r\n\r\n咱们还需要在`dto`包里新建一个封装json返回结果的类`Result.java`，设计成泛型。\r\n\r\n**Result.java**\r\n``` java\r\npackage com.soecode.lyf.dto;\r\n\r\n/**\r\n * 封装json对象，所有返回结果都使用它\r\n */\r\npublic class Result<T> {\r\n\r\n\tprivate boolean success;// 是否成功标志\r\n\r\n\tprivate T data;// 成功时返回的数据\r\n\r\n\tprivate String error;// 错误信息\r\n\r\n\tpublic Result() {\r\n\t}\r\n\r\n\t// 成功时的构造器\r\n\tpublic Result(boolean success, T data) {\r\n\t\tthis.success = success;\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\t// 错误时的构造器\r\n\tpublic Result(boolean success, String error) {\r\n\t\tthis.success = success;\r\n\t\tthis.error = error;\r\n\t}\r\n\r\n\t// 省略getter和setter方法\r\n}\r\n\r\n```\r\n\r\n------------\r\n\r\n最后，我们写web层，也就是controller，我们在`web`包下新建`BookController.java`文件。\r\n\r\n**BookController.java**\r\n``` java\r\npackage com.soecode.lyf.web;\r\n\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.ui.Model;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\n\r\nimport com.soecode.lyf.dto.AppointExecution;\r\nimport com.soecode.lyf.dto.Result;\r\nimport com.soecode.lyf.entity.Book;\r\nimport com.soecode.lyf.service.BookService;\r\n\r\n@Controller\r\n@RequestMapping(\"/book\") // url:/模块/资源/{id}/细分 /seckill/list\r\npublic class BookController {\r\n\r\n\tprivate Logger logger = LoggerFactory.getLogger(this.getClass());\r\n\r\n\t@Autowired\r\n\tprivate BookService bookService;\r\n\r\n\t@RequestMapping(value = \"/list\", method = RequestMethod.GET)\r\n\tprivate String list(Model model) {\r\n\t\tList<Book> list = bookService.getList();\r\n\t\tmodel.addAttribute(\"list\", list);\r\n\t\t// list.jsp + model = ModelAndView\r\n\t\treturn \"list\";// WEB-INF/jsp/\"list\".jsp\r\n\t}\r\n\r\n\t// ajax json\r\n\t@RequestMapping(value = \"/{bookId}/detail\", method = RequestMethod.GET)\r\n\t@ResponseBody\r\n\tprivate String detail(@PathVariable(\"bookId\") Long bookId, Model model) {\r\n\t\tif (bookId == null) {\r\n\t\t\treturn \"redirect:/book/list\";\r\n\t\t}\r\n\t\tBook book = bookService.getById(bookId);\r\n\t\tif (book == null) {\r\n\t\t\treturn \"forward:/book/list\";\r\n\t\t}\r\n\t\tmodel.addAttribute(\"book\", book);\r\n\t\treturn \"detail\";\r\n\t}\r\n\r\n\t@RequestMapping(value = \"/{bookId}/appoint\", method = RequestMethod.POST, produces = {\r\n\t\t\t\"application/json; charset=utf-8\" })\r\n\tprivate Result<AppointExecution> appoint(@PathVariable(\"bookId\") Long bookId, @Param(\"studentId\") Long studentId) {\r\n\t\tif (studentId == null || studentId.equals(\"\")) {\r\n\t\t\treturn new Result<>(false, \"学号不能为空\");\r\n\t\t}\r\n\t\tAppointExecution execution = bookService.appoint(bookId, studentId);\r\n\t\treturn new Result<AppointExecution>(true, execution);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n因为我比较懒，所以我们就不测试controller了,好讨厌写前端，呜呜呜~\r\n\r\n到此，我们的SSM框架整合配置，与应用实例部分已经结束了，我把所有源码和jar包一起打包放在了我的GitHub上，需要的可以去下载，喜欢就给个star吧，这篇东西写了两个晚上也不容易啊。\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}